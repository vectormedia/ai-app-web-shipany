# ShipAny Template Two - 事件总线机制分析

## 概述

ShipAny Template Two **没有传统意义上的集中式事件总线系统**，而是采用现代 React 生态的状态管理和事件处理模式。项目主要通过 **React Context**、**Custom Hooks**、**原生 DOM 事件** 和 **服务端状态同步** 来实现组件间通信和事件处理。

## 事件处理架构分析

### 架构特点
- **去中心化设计**: 没有全局事件总线
- **React 原生机制**: 主要依赖 React 的状态管理
- **分层通信**: Context 提供者 + 消费者模式
- **类型安全**: 完整的 TypeScript 类型定义

## 1. React Context 状态管理

### 1.1 AppContext - 全局应用状态

**文件位置**: `src/shared/contexts/app.tsx`

```typescript
export interface ContextValue {
  user: User | null;                          // 当前用户
  isCheckSign: boolean;                       // 登录检查状态
  isShowSignModal: boolean;                   // 登录模态框显示
  setIsShowSignModal: (show: boolean) => void;// 登录模态框控制
  isShowPaymentModal: boolean;                // 支付模态框显示
  setIsShowPaymentModal: (show: boolean) => void;// 支付模态框控制
  configs: Record<string, string>;            // 应用配置
  fetchUserCredits: () => Promise<void>;      // 刷新用户积分
  fetchUserInfo: () => Promise<void>;         // 刷新用户信息
}
```

**事件流程**:
```
1. 组件触发状态改变
   ↓
2. Context 状态更新
   ↓
3. 消费组件自动重渲染
   ↓
4. UI 响应状态变化
```

**使用示例**:
```typescript
// 状态消费
const { user, setIsShowPaymentModal, fetchUserCredits } = useAppContext();

// 事件触发
const handleShowPayment = () => {
  setIsShowPaymentModal(true);  // 全局状态改变
};

// 状态响应
useEffect(() => {
  if (user) {
    fetchUserCredits();  // 用户状态变化响应
  }
}, [user]);
```

### 1.2 ChatContext - 聊天状态管理

**文件位置**: `src/shared/contexts/chat.tsx`

```typescript
export interface ContextValue {
  chat: Chat | null;                    // 当前聊天会话
  setChat: (chat: Chat | null) => void; // 设置当前会话
  chats: Chat[];                        // 聊天列表
  setChats: (chats: Chat[]) => void;    // 更新聊天列表
}
```

**聊天事件流**:
```
用户发送消息 → setChat更新 → 消费组件重渲染 → UI更新
新会话创建   → setChats更新 → 侧边栏刷新   → 列表显示
```

## 2. 原生 DOM 事件处理

### 2.1 媒体查询事件监听

**文件位置**: `src/shared/hooks/use-media-query.ts`

```typescript
export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);

    // 初始状态设置
    setMatches(mediaQuery.matches);

    // 事件监听器
    const handleChange = (event: MediaQueryListEvent) => {
      setMatches(event.matches);
    };

    // 添加监听器
    mediaQuery.addEventListener('change', handleChange);

    // 清理函数
    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, [query]);

  return matches;
}
```

**事件流程**:
```
屏幕尺寸变化 → MediaQueryList事件 → handleChange → 状态更新 → 组件重渲染
```

### 2.2 移动设备检测

**文件位置**: `src/shared/hooks/use-mobile.ts`

```typescript
export function useMobile() {
  return useMediaQuery('(max-width: 768px)');
}
```

**响应式事件处理**:
```typescript
function ResponsiveComponent() {
  const isMobile = useMobile();

  return (
    <div>
      {isMobile ? <MobileLayout /> : <DesktopLayout />}
    </div>
  );
}
```

## 3. 异步状态同步机制

### 3.1 配置获取事件

**AppContextProvider 中的异步事件**:

```typescript
const fetchConfigs = async function () {
  try {
    const resp = await fetch('/api/config/get-configs', {
      method: 'POST',
    });
    const { code, message, data } = await resp.json();
    if (code !== 0) {
      throw new Error(message);
    }
    setConfigs(data);  // 状态更新事件
  } catch (e) {
    console.log('fetch configs failed:', e);
  }
};

// 初始化时触发
useEffect(() => {
  fetchConfigs();
}, []);
```

### 3.2 用户状态同步

```typescript
const fetchUserInfo = async function () {
  try {
    const resp = await fetch('/api/user/get-user-info', { method: 'POST' });
    const { data } = await resp.json();
    setUser(data);  // 全局用户状态更新
  } catch (e) {
    console.log('fetch user info failed:', e);
  }
};

// 会话变化触发
useEffect(() => {
  if (session?.user) {
    setUser(session.user as User);
    fetchUserInfo();  // 同步最新用户信息
  } else {
    setUser(null);
  }
}, [session]);
```

## 4. 认证状态事件流

### 4.1 Better-auth 集成

```typescript
// 会话监听
const { data: session, isPending } = useSession();

// 会话变化事件处理
useEffect(() => {
  if (session?.user) {
    setUser(session.user as User);
    fetchUserInfo();
  } else {
    setUser(null);
  }
}, [session]);

// 加载状态事件处理
useEffect(() => {
  setIsCheckSign(isPending);
}, [isPending]);
```

**认证事件流程**:
```
用户登录 → Better-auth状态更新 → useSession hook → AppContext更新 → 全局用户状态同步
```

### 4.2 Google One Tap 事件

```typescript
const showOneTap = async function (configs: Record<string, string>) {
  try {
    const authClient = getAuthClient(configs);
    await authClient.oneTap({
      callbackURL: '/',
      onPromptNotification: (notification: any) => {
        console.log('One Tap prompt notification:', notification);
      },
    });
  } catch (error) {
    // 静默处理 One Tap 取消错误
  }
};

// 条件触发 One Tap
useEffect(() => {
  if (
    configs?.google_client_id &&
    configs.google_one_tap_enabled === 'true' &&
    !session &&
    !isPending &&
    !oneTapInitialized.current
  ) {
    oneTapInitialized.current = true;
    showOneTap(configs);
  }
}, [configs, session, isPending]);
```

## 5. 语言检测事件系统

### 5.1 LocaleDetector 组件

**文件位置**: `src/shared/blocks/common/locale-detector.tsx`

```typescript
export function LocaleDetector() {
  const [showBanner, setShowBanner] = useState(false);
  const [browserLocale, setBrowserLocale] = useState<string | null>(null);

  // 浏览器语言检测
  const detectBrowserLocale = (): string | null => {
    const browserLang = navigator.language || navigator.userLanguage;
    const langCode = browserLang.split('-')[0].toLowerCase();
    return locales.includes(langCode) ? langCode : null;
  };

  // 语言切换事件
  const switchToLocale = useCallback(
    (locale: string) => {
      router.replace(pathname, { locale });     // 路由更新
      cacheSet(PREFERRED_LOCALE_KEY, locale);   // 缓存更新
      setShowBanner(false);                     // UI 状态更新
    },
    [router, pathname]
  );

  // 初始化检测事件
  useEffect(() => {
    const detectedLocale = detectBrowserLocale();
    const dismissed = isDismissed();
    const preferredLocale = cacheGet(PREFERRED_LOCALE_KEY);

    // 自动切换逻辑
    if (preferredLocale && preferredLocale !== currentLocale) {
      switchToLocale(preferredLocale);
      return;
    }

    // 显示提示横幅
    if (detectedLocale && detectedLocale !== currentLocale && !dismissed) {
      setShowBanner(true);
    }
  }, [currentLocale, switchToLocale]);
}
```

**语言检测事件流**:
```
页面加载 → 检测浏览器语言 → 比较当前语言 → 显示切换提示 → 用户选择 → 路由跳转 → 缓存保存
```

## 6. UI 事件和布局响应

### 6.1 侧边栏展开/收起事件

```typescript
// useSidebar hook
const SidebarProvider = ({ children }: SidebarProviderProps) => {
  const [state, setState] = useState<SidebarState>({
    open: defaultOpen,
    openMobile: false,
  });

  const toggleSidebar = useCallback(() => {
    return setState((state) => ({
      ...state,
      open: !state.open,
    }));
  }, []);

  // 移动端状态管理
  const setOpenMobile = useCallback((open: boolean) => {
    setState((state) => ({ ...state, openMobile: open }));
  }, []);
};
```

### 6.2 布局调整事件

```typescript
// LocaleDetector 中的布局调整
useEffect(() => {
  if (showBanner && bannerRef.current) {
    const bannerHeight = bannerRef.current.offsetHeight;

    // 调整头部位置
    const header = document.querySelector('header');
    if (header) {
      header.style.top = `${bannerHeight}px`;
    }

    // 调整侧边栏位置
    const sidebarContainer = document.querySelector('[data-slot="sidebar-container"]');
    if (sidebarContainer) {
      sidebarContainer.style.top = `${bannerHeight}px`;
      sidebarContainer.style.height = `calc(100vh - ${bannerHeight}px)`;
    }
  }

  // 清理函数
  return () => {
    // 重置位置
    const header = document.querySelector('header');
    if (header) header.style.top = '0px';
  };
}, [showBanner]);
```

## 7. 表单和交互事件

### 7.1 支付流程事件

```typescript
const handlePayment = async () => {
  try {
    // 触发支付模态框
    setIsShowPaymentModal(true);

    // 发送支付请求
    const response = await fetch('/api/payment/checkout', {
      method: 'POST',
      body: JSON.stringify(paymentData),
    });

    const result = await response.json();

    if (result.code === 0) {
      // 支付成功事件
      window.location.href = result.data.checkoutUrl;
    }
  } catch (error) {
    console.error('Payment error:', error);
  }
};
```

### 7.2 文件上传事件

```typescript
const handleFileUpload = async (file: File) => {
  const formData = new FormData();
  formData.append('file', file);

  try {
    const response = await fetch('/api/storage/upload-image', {
      method: 'POST',
      body: formData,
    });

    const result = await response.json();

    if (result.code === 0) {
      // 上传成功事件
      onUploadSuccess(result.data.url);
    }
  } catch (error) {
    console.error('Upload error:', error);
  }
};
```

## 8. 缓存和持久化事件

### 8.1 本地缓存操作

**文件位置**: `src/shared/lib/cache.ts` (推测)

```typescript
// 缓存设置事件
cacheSet(PREFERRED_LOCALE_KEY, locale);

// 缓存获取
const preferredLocale = cacheGet(PREFERRED_LOCALE_KEY);

// 缓存清理
const dismissed = isDismissed();
```

### 8.2 状态持久化

```typescript
// 语言偏好持久化
const switchToLocale = useCallback((locale: string) => {
  router.replace(pathname, { locale });
  cacheSet(PREFERRED_LOCALE_KEY, locale);  // 持久化事件
  setShowBanner(false);
}, [router, pathname]);

// 横幅关闭状态持久化
const handleDismiss = () => {
  setDismissed();          // 设置关闭状态
  setShowBanner(false);    // 更新 UI 状态
};
```

## 9. 错误处理和重试机制

### 9.1 API 调用错误处理

```typescript
const fetchUserCredits = async function () {
  try {
    const resp = await fetch('/api/user/get-user-credits', {
      method: 'POST',
    });

    if (!resp.ok) {
      throw new Error(`fetch failed with status: ${resp.status}`);
    }

    const { code, message, data } = await resp.json();
    if (code !== 0) {
      throw new Error(message);
    }

    setUser({ ...user, credits: data });
  } catch (e) {
    console.log('fetch user credits failed:', e);
    // 可以添加错误状态更新
    // setError(e.message);
  }
};
```

### 9.2 One Tap 错误处理

```typescript
const showOneTap = async function (configs: Record<string, string>) {
  try {
    const authClient = getAuthClient(configs);
    await authClient.oneTap({
      callbackURL: '/',
      onPromptNotification: (notification: any) => {
        console.log('One Tap prompt notification:', notification);
      },
    });
  } catch (error) {
    // 静默处理 One Tap 取消错误
    // 这些错误发生在用户关闭提示框或拒绝登录时
    // 常见错误: FedCM NetworkError, AbortError 等
  }
};
```

## 10. 事件流程总结

### 10.1 典型事件流程

```
1. 用户操作 (点击、输入、滚动等)
   ↓
2. 事件处理函数执行
   ↓
3. 状态更新 (useState, Context)
   ↓
4. React 重新渲染
   ↓
5. UI 响应变化
   ↓
6. 可能触发副作用 (useEffect)
   ↓
7. API 调用或其他异步操作
   ↓
8. 状态同步完成
```

### 10.2 跨组件通信模式

```
组件A 触发事件
   ↓
Context 状态更新
   ↓
组件B 自动重渲染
   ↓
组件C 响应状态变化
   ↓
组件D 执行副作用
```

## 11. 对比传统事件总线

### 11.1 优势分析

**React Context 模式优势**:
- **类型安全**: 完整的 TypeScript 支持
- **性能优化**: React 的优化重渲染机制
- **调试友好**: React DevTools 支持
- **生态集成**: 与 React 生态无缝集成

**传统事件总线劣势**:
- 类型安全难以保证
- 事件流难以追踪
- 内存泄漏风险
- 调试困难

### 11.2 适用场景

**当前架构适合**:
- 中小型应用
- React 生态项目
- 类型安全要求高
- 团队熟悉 React

**事件总线适合**:
- 大型复杂应用
- 跨框架通信
- 插件系统
- 实时事件流

## 总结

ShipAny Template Two 采用现代 React 状态管理模式，通过 **React Context**、**Custom Hooks** 和 **原生事件** 实现了高效的事件处理机制：

1. **React Context** 提供全局状态管理
2. **Custom Hooks** 封装复用事件逻辑
3. **原生事件** 处理 DOM 和浏览器事件
4. **异步状态同步** 保证数据一致性
5. **类型安全** 贯穿整个事件系统

这种设计虽然没有传统的事件总线，但充分利用了 React 的优势，提供了类型安全、性能优良且易于维护的事件处理解决方案。